<?xml version="1.0" encoding="UTF-8" ?>  
<!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd" >
<generatorConfiguration>
    <!-- 数据库配置文件 -->
    <properties resource="jdbc.properties" />
    <classPathEntry location="D:\project\JavaWK\ccmz\libs\mysql-connector-java-5.1.29.jar" />
    
    <context id="context1" targetRuntime="MyBatis3">
        <property name="javaFileEncoding" value="UTF-8" />
        <property name="autoDelimitKeywords" value="true" />
        <property name="javaFormatter" value="org.mybatis.generator.api.dom.DefaultJavaFormatter" />
        <property name="xmlFormatter" value="org.mybatis.generator.api.dom.DefaultXmlFormatter" />
        
		 <!--对注释进行控制--> 
		 <commentGenerator> 
		 	<property name="suppressDate" value="true"/> 
		 	<property name="suppressAllComments" value="true"/> 
		 </commentGenerator>

        <!-- 数据库连接 -->
        <jdbcConnection driverClass="${jdbc.driverClassName}" connectionURL="${jdbc.url}" userId="${jdbc.username}" password="${jdbc.password}" />


        <!-- 数据库的生成配置 -->
        <javaModelGenerator targetPackage="com.yixun.ccmz.domain" targetProject="src/main/java">
	        <!--  for MyBatis3/MyBatis3Simple
	            自动为每一个生成的类创建一个构造方法，构造方法包含了所有的field；而不是使用setter；
	         -->        
        	<property name="constructorBased" value="true"/>
            <property name="enableSubPackages" value="false" />
             <!-- 设置是否在getter方法中，对String类型字段调用trim()方法 -->
            <property name="trimStrings" value="true" />        
 			<!-- 设置一个根对象， 如果设置了这个根对象，那么生成的keyClass或者recordClass会继承这个类；在Table的rootClass属性中可以覆盖该选项 注意：如果在key class或者record class中有root class相同的属性，MBG就不会重新生成这些属性了，包括： 1，属性名相同，类型相同，有相同的getter/setter方法； --> 
 			<property name="rootClass" value="com.yixun.ccmz.domain.BaseModel"/>      
        </javaModelGenerator>
        <sqlMapGenerator targetPackage="com.yixun.ccmz.dao" targetProject="src/main/resources">
            <property name="enableSubPackages" value="false" />
            <property name="trimStrings" value="true" />           
        </sqlMapGenerator>
        <javaClientGenerator targetPackage="com.yixun.ccmz.dao" targetProject="src/main/java" type="XMLMAPPER" >
            <property name="enableSubPackages" value="false" />
            <property name="trimStrings" value="true" />           
        </javaClientGenerator>
        
        <!-- 以上部分配置固定，无需改动，此处往下开始项目设置 -->
        
        <!-- user表 
        <table tableName="user" domainObjectName="User">
            <property name="useActualColumnNames" value="true" />
            <generatedKey column="id" sqlStatement="SELECT LAST_INSERT_ID()" identity="true" />
        </table>-->
        <table tableName="aspnet_applications" domainObjectName="Application" schema="public" delimitIdentifiers="true" delimitAllColumns="true">
         	<!-- 参考 javaModelGenerator 的 constructorBased属性
         	<property name="constructorBased" value="false"/>-->
         	
         	<!-- 默认为false，如果设置为true，在生成的SQL中，table名字不会加上catalog或schema； -->
         	<property name="ignoreQualifiersAtRuntime" value="false"/>
         	
         	<!-- 参考 javaModelGenerator 的 immutable 属性 -->
         	<property name="immutable" value="false"/>
         	
         	 <!-- 指定是否只生成domain类，如果设置为true，只生成domain类，如果还配置了sqlMapGenerator，那么在mapper XML文件中，只生成resultMap元素 -->
         	 <property name="modelOnly" value="false"/>
         	 
         	 <!-- 如果设置为true，生成的model类会直接使用column本身的名字，而不会再使用驼峰命名方法，比如BORN_DATE，生成的属性名字就是BORN_DATE,而不会是bornDate -->
         	 <property name="useActualColumnNames" value="true"/>
         	 
 			<!-- generatedKey用于生成生成主键的方法， 如果设置了该元素，MBG会在生成的<insert>元素中生成一条正确的<selectKey>元素，该元素可选 
 				column:主键的列名； 
 				sqlStatement：要生成的selectKey语句，有以下可选项： 
 					Cloudscape:相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() 
 					DB2 :相当于selectKey的SQL为： VALUES IDENTITY_VAL_LOCAL() 
 					DB2_MF :相当于selectKey的SQL为：SELECT IDENTITY_VAL_LOCAL() FROM SYSIBM.SYSDUMMY1 
 					Derby :相当于selectKey的SQL为：VALUES IDENTITY_VAL_LOCAL() 
 					HSQLDB :相当于selectKey的SQL为：CALL IDENTITY() 
 					Informix :相当于selectKey的SQL为：select dbinfo('sqlca.sqlerrd1') from systables where tabid=1 
 					MySql :相当于selectKey的SQL为：SELECT LAST_INSERT_ID() 
 					SqlServer :相当于selectKey的SQL为：SELECT SCOPE_IDENTITY() 
 					SYBASE :相当于selectKey的SQL为：SELECT @@IDENTITY 
 					JDBC :相当于在生成的insert元素上添加useGeneratedKeys="true"和keyProperty属性 
 			<generatedKey column="" sqlStatement=""/> -->    
 			  	
 			<!-- 该元素会在根据表中列名计算对象属性名之前先重命名列名，非常适合用于表中的列都有公用的前缀字符串的时候， 
 			比如列名为：CUST_ID,CUST_NAME,CUST_EMAIL,CUST_ADDRESS等； 那么就可以设置searchString为"^CUST_"，并使用空白替换，
 			那么生成的Customer对象中的属性名称就不是 custId,custName等，而是先被替换为ID,NAME,EMAIL,然后变成属性：id，name，email； 
 			注意，MBG是使用java.util.regex.Matcher.replaceAll来替换searchString和replaceString的， 如果使用了columnOverride元素，该属性无效； 
 			<columnRenamingRule searchString="" replaceString=""/> -->
		 
		 	<!-- 用来修改表中某个列的属性，MBG会使用修改后的列来生成domain的属性；
            	column:要重新设置的列名；
            	注意，一个table元素中可以有多个columnOverride元素
		 	<columnOverride column="username">
		 		<property name="property" value="userName"/>
		 		<property name="javaType" value=""/>
		 		<property name="jdbcType" value=""/>
		 	 -->
			<!-- ignoreColumn设置一个MGB忽略的列，如果设置了改列，那么在生成的domain中，生成的SQL中，都不会有该列出现 
			column:指定要忽略的列的名字； 
			delimitedColumnName：参考table元素的delimitAllColumns配置，默认为false 
			注意，一个table元素中可以有多个ignoreColumn元素 
			<ignoreColumn column="deptId" delimitedColumnName=""/> --> 	 
        </table>
    </context>
</generatorConfiguration>